#  NumPy基础：数组和矢量计算

## 1、NumPy处理数据的优势
### 可以高效处理大数组的数据。
### 因为：
### 1) NumPy是在⼀个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期⼯作。比起Python的内置序列，NumPy数组使用的内存更少。
### 2) NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环。

## 2、NumPy的ndarray：一种多维数组对象


```python
import numpy as np
```


```python
data = np.random.randn(2, 3)
```


```python
data
```




    array([[-0.75913749, -0.64476707, -0.41116409],
           [ 1.74914357, -0.50333562, -1.34449206]])




```python
data * 10
```




    array([[ -7.59137486,  -6.44767071,  -4.11164088],
           [ 17.49143569,  -5.03335623, -13.44492056]])




```python
data + data
```




    array([[-1.51827497, -1.28953414, -0.82232818],
           [ 3.49828714, -1.00667125, -2.68898411]])



### 1) shape(数组大小) 、 dtype(数据元素类型) 、ndim(数组维度)


```python
data.shape
```




    (2, 3)




```python
data.dtype
```




    dtype('float64')




```python
data.ndim
```




    2



#### 可以通过astype转换数据类型


```python
data = data.astype(np.int64)
```


```python
data
```




    array([[ 0,  0,  0],
           [ 1,  0, -1]], dtype=int64)




```python
data.dtype
```




    dtype('int64')



若字符串内全为数字，则可以利用astype转换为数字


```python
numeric_str = np.array(['1.2', '3.4', '5.6', '7.6'])
```


```python
numeric_str
```




    array(['1.2', '3.4', '5.6', '7.6'], dtype='<U3')




```python
numeric_str.astype(np.float64)
```




    array([1.2, 3.4, 5.6, 7.6])




```python
numeric_str
```




    array(['1.2', '3.4', '5.6', '7.6'], dtype='<U3')




```python
numeric_str = numeric_str.astype(float)
```


```python
numeric_str
```




    array([1.2, 3.4, 5.6, 7.6])



### 2) 创建ndarray

#### 列表变数组


```python
data1 = [6, 7.5, 8, 0, 1]
```


```python
arr1 = np.array(data1)
```


```python
arr1
```




    array([6. , 7.5, 8. , 0. , 1. ])



#### 嵌套列表变多行数组


```python
data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
```


```python
arr2 = np.array(data2)
```


```python
arr2
```




    array([[1, 2, 3, 4],
           [5, 6, 7, 8]])




```python
arr2.ndim
```




    2




```python
arr2.shape
```




    (2, 4)




```python
arr1.dtype
```




    dtype('float64')




```python
arr2.dtype
```




    dtype('int32')



#### zeros 、ones 、empty


```python
np.zeros(10)
```




    array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])




```python
np.zeros((3,6))
```




    array([[0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0.]])




```python
np.zeros((2,3,2))
```




    array([[[0., 0.],
            [0., 0.],
            [0., 0.]],
    
           [[0., 0.],
            [0., 0.],
            [0., 0.]]])




```python
np.ones(5)
```




    array([1., 1., 1., 1., 1.])




```python
np.ones((2,3))
```




    array([[1., 1., 1.],
           [1., 1., 1.]])




```python
np.ones((2,3,3))
```




    array([[[1., 1., 1.],
            [1., 1., 1.],
            [1., 1., 1.]],
    
           [[1., 1., 1.],
            [1., 1., 1.],
            [1., 1., 1.]]])




```python
np.empty((2,3,2))
```




    array([[[0., 0.],
            [0., 0.],
            [0., 0.]],
    
           [[0., 0.],
            [0., 0.],
            [0., 0.]]])



#### arange(内置函数版range)


```python
np.arange(15)
```




    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])



![6.png](https://github.com/ta00231/data_analysis/blob/main/picture/6.png)
其他详细函数


```python
np.eye(5,5)
```




    array([[1., 0., 0., 0., 0.],
           [0., 1., 0., 0., 0.],
           [0., 0., 1., 0., 0.],
           [0., 0., 0., 1., 0.],
           [0., 0., 0., 0., 1.]])



### 3) NumPy数组的运算

### 1. 矢量化


```python
arr = np.array([[1., 2., 3.],[4., 5., 6.]])
```


```python
arr
```




    array([[1., 2., 3.],
           [4., 5., 6.]])




```python
arr * arr
```




    array([[ 1.,  4.,  9.],
           [16., 25., 36.]])




```python
arr - arr
```




    array([[0., 0., 0.],
           [0., 0., 0.]])




```python
1/ arr
```




    array([[1.        , 0.5       , 0.33333333],
           [0.25      , 0.2       , 0.16666667]])




```python
arr ** 0.5
```




    array([[1.        , 1.41421356, 1.73205081],
           [2.        , 2.23606798, 2.44948974]])




```python
arr2 = np.array([[0., 4., 1.],[7., 2., 12.]])
```


```python
arr2
```




    array([[ 0.,  4.,  1.],
           [ 7.,  2., 12.]])




```python
arr2 > arr
```




    array([[False,  True, False],
           [ True, False,  True]])



### 2. 基本索引和切片


```python
arr = np.arange(10)
```


```python
arr
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
arr[5]
```




    5




```python
arr[5:8]
```




    array([5, 6, 7])




```python
arr[5:8] = 12
```


```python
arr
```




    array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])



跟列表最重要的区别在于，数组切⽚是原始数组的视图。
这意味着数据不会被复制，视图上的任何修改都会直接反映到源数组上。

#### narray数组


```python
arr_slice = arr[5:8]
```


```python
arr_slice
```




    array([12, 12, 12])




```python
arr_slice[0] = 12456
```


```python
arr_slice
```




    array([12456,    12,    12])




```python
arr
```




    array([    0,     1,     2,     3,     4, 12456,    12,    12,     8,
               9])




```python
arr_slice[:] = 64
```


```python
arr
```




    array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])



#### list列表


```python
list1 = [e for e in range(10) ]
```


```python
list1
```




    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]




```python
list_slice = list1[5:8]
```


```python
list_slice
```




    [5, 6, 7]




```python
list_slice[0] = 123456
```


```python
list_slice
```




    [123456, 6, 7]




```python
list1
```




    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]




```python
list_slice[:] = 64
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-93-3c542a4aa37e> in <module>
    ----> 1 list_slice[:] = 64
    

    TypeError: can only assign an iterable


在⼀个⼆维数组中，各索引位置上的元素不再是标量⽽是⼀维数组。


```python
arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
```


```python
arr2d
```




    array([[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]])




```python
arr2d[2]
```




    array([7, 8, 9])




```python
arr2d[0][1]
```




    2




```python
arr2d[1][2]
```




    6




```python
arr2d[1, 2]
```




    6



[x][y] ; [x, y] 两种等价

在多维数组中，如果省略了后⾯的索引，则返回对象会是⼀个维度低⼀点的ndarray（它含有⾼⼀级维度上的所有数据）。


```python
arr3d = [[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]]
```


```python
arr3d = np.array(arr3d)
```


```python
arr3d
```




    array([[[ 1,  2,  3],
            [ 4,  5,  6]],
    
           [[ 7,  8,  9],
            [10, 11, 12]]])




```python
arr3d[0]
```




    array([[1, 2, 3],
           [4, 5, 6]])




```python
old_values = arr3d[0].copy()
```


```python
arr3d[0] = 42
```


```python
arr3d
```




    array([[[42, 42, 42],
            [42, 42, 42]],
    
           [[ 7,  8,  9],
            [10, 11, 12]]])




```python
old_values
```




    array([[1, 2, 3],
           [4, 5, 6]])




```python
arr3d[0] = old_values
```


```python
arr3d
```




    array([[[ 1,  2,  3],
            [ 4,  5,  6]],
    
           [[ 7,  8,  9],
            [10, 11, 12]]])




```python
arr3d[0,1]
```




    array([4, 5, 6])




```python
x = arr3d[0]
```


```python
x
```




    array([[1, 2, 3],
           [4, 5, 6]])




```python
x[1]
```




    array([4, 5, 6])



在上⾯所有这些选取数组⼦集的例⼦中，返回的数组都是视图。

#### 切片索引


```python
arr
```




    array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])




```python
arr[1:6]
```




    array([ 1,  2,  3,  4, 64])




```python
arr2d
```




    array([[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]])



##### 行切片索引


```python
arr2d[:2]
```




    array([[1, 2, 3],
           [4, 5, 6]])



##### 行列切片索引


```python
arr2d[:2, 1:]
```




    array([[2, 3],
           [5, 6]])



##### 整数、切片混合索引


```python
arr2d[1, :2]
```




    array([4, 5])




```python
arr2d[:2, 2]
```




    array([3, 6])



同理对数组的切片表达式赋值也会扩散到整个选区


```python
arr2d[:2, 1:] = 0
```


```python
arr2d
```




    array([[1, 0, 0],
           [4, 0, 0],
           [7, 8, 9]])



#### 布尔型索引


```python
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
```


```python
data = np.random.randn(7, 4)
```


```python
names
```




    array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], dtype='<U4')




```python
data
```




    array([[-0.50156468,  1.84559173,  0.48835664, -0.54642287],
           [ 1.36064518,  0.7188471 ,  0.15356331,  0.66531293],
           [-1.03140075,  0.77960737,  1.29530801,  0.22326433],
           [-0.69875332,  0.15052888,  1.05503964,  1.39358565],
           [-0.66945197, -0.08379911, -0.60480708,  0.04382344],
           [ 0.08265654,  1.27574025,  0.62292719, -0.93001427],
           [ 0.50808643, -0.42666336,  1.41707522, -0.15116875]])



假设每个名字都对应data数组中的⼀⾏，⽽我们想要选出对应于名字"Bob"的所有⾏


```python
names == 'Bob'
```




    array([ True, False, False,  True, False, False, False])




```python
data[names == 'Bob']
```




    array([[-0.50156468,  1.84559173,  0.48835664, -0.54642287],
           [-0.69875332,  0.15052888,  1.05503964,  1.39358565]])



布尔型数组的⻓度必须跟被索引的轴⻓度⼀致


```python
boolean_arr1 = (names == 'Bob')
```


```python
boolean_arr1
```




    array([ True, False, False,  True, False, False, False])




```python
data[boolean_arr1]
```




    array([[-0.50156468,  1.84559173,  0.48835664, -0.54642287],
           [-0.69875332,  0.15052888,  1.05503964,  1.39358565]])




```python
data[boolean_arr1, 2:]
```




    array([[ 0.48835664, -0.54642287],
           [ 1.05503964,  1.39358565]])




```python
data[boolean_arr1, 3]
```




    array([-0.54642287,  1.39358565])



要选择除"Bob"以外的其他值，既可以使⽤不等于符号（!=），也可以通过~对条件进⾏否定


```python
names != 'Bob'
```




    array([False,  True,  True, False,  True,  True,  True])




```python
cond = boolean_arr1
```


```python
data[~cond]
```




    array([[ 1.36064518,  0.7188471 ,  0.15356331,  0.66531293],
           [-1.03140075,  0.77960737,  1.29530801,  0.22326433],
           [-0.66945197, -0.08379911, -0.60480708,  0.04382344],
           [ 0.08265654,  1.27574025,  0.62292719, -0.93001427],
           [ 0.50808643, -0.42666336,  1.41707522, -0.15116875]])




```python
data
```




    array([[-0.50156468,  1.84559173,  0.48835664, -0.54642287],
           [ 1.36064518,  0.7188471 ,  0.15356331,  0.66531293],
           [-1.03140075,  0.77960737,  1.29530801,  0.22326433],
           [-0.69875332,  0.15052888,  1.05503964,  1.39358565],
           [-0.66945197, -0.08379911, -0.60480708,  0.04382344],
           [ 0.08265654,  1.27574025,  0.62292719, -0.93001427],
           [ 0.50808643, -0.42666336,  1.41707522, -0.15116875]])




```python
mask = (names == 'Bob') | (names == 'Will')
```


```python
mask
```




    array([ True, False,  True,  True,  True, False, False])




```python
data[mask]
```




    array([[-0.50156468,  1.84559173,  0.48835664, -0.54642287],
           [-1.03140075,  0.77960737,  1.29530801,  0.22326433],
           [-0.69875332,  0.15052888,  1.05503964,  1.39358565],
           [-0.66945197, -0.08379911, -0.60480708,  0.04382344]])



通过布尔型数组设置值是⼀种经常⽤到的⼿段。为了将data中的所有负值都设置为0，我们只需


```python
data[data < 0] = 0
```


```python
data
```




    array([[0.        , 1.84559173, 0.48835664, 0.        ],
           [1.36064518, 0.7188471 , 0.15356331, 0.66531293],
           [0.        , 0.77960737, 1.29530801, 0.22326433],
           [0.        , 0.15052888, 1.05503964, 1.39358565],
           [0.        , 0.        , 0.        , 0.04382344],
           [0.08265654, 1.27574025, 0.62292719, 0.        ],
           [0.50808643, 0.        , 1.41707522, 0.        ]])




```python
data[cond] = 7 
```


```python
data
```




    array([[7.        , 7.        , 7.        , 7.        ],
           [1.36064518, 0.7188471 , 0.15356331, 0.66531293],
           [0.        , 0.77960737, 1.29530801, 0.22326433],
           [7.        , 7.        , 7.        , 7.        ],
           [0.        , 0.        , 0.        , 0.04382344],
           [0.08265654, 1.27574025, 0.62292719, 0.        ],
           [0.50808643, 0.        , 1.41707522, 0.        ]])



#### 花式索引(Fancy indexing)


```python
arr = np.empty((8,4))
```


```python
for i in range(8):
    arr[i] = i
```


```python
arr
```




    array([[0., 0., 0., 0.],
           [1., 1., 1., 1.],
           [2., 2., 2., 2.],
           [3., 3., 3., 3.],
           [4., 4., 4., 4.],
           [5., 5., 5., 5.],
           [6., 6., 6., 6.],
           [7., 7., 7., 7.]])




```python
arr[[4,3,0,6]]
```




    array([[4., 4., 4., 4.],
           [3., 3., 3., 3.],
           [0., 0., 0., 0.],
           [6., 6., 6., 6.]])




```python
arr[[-3, -5, -7]]
```




    array([[5., 5., 5., 5.],
           [3., 3., 3., 3.],
           [1., 1., 1., 1.]])




```python
arr = np.arange(32).reshape((8,4))
```


```python
arr
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15],
           [16, 17, 18, 19],
           [20, 21, 22, 23],
           [24, 25, 26, 27],
           [28, 29, 30, 31]])




```python
arr[[1,5,7,2],[0,3,1,2]]
```




    array([ 4, 23, 29, 10])




```python
arr[[1,5,7,2]][:,[0,3,1,2]]
```




    array([[ 4,  7,  5,  6],
           [20, 23, 21, 22],
           [28, 31, 29, 30],
           [ 8, 11,  9, 10]])




```python
arr[[1,5,7,2]]
```




    array([[ 4,  5,  6,  7],
           [20, 21, 22, 23],
           [28, 29, 30, 31],
           [ 8,  9, 10, 11]])




```python
arr[:,[0,3,1,2]]
```




    array([[ 0,  3,  1,  2],
           [ 4,  7,  5,  6],
           [ 8, 11,  9, 10],
           [12, 15, 13, 14],
           [16, 19, 17, 18],
           [20, 23, 21, 22],
           [24, 27, 25, 26],
           [28, 31, 29, 30]])



### 3. 数组转置和轴对换


```python
arr = np.arange(15).reshape((3,5))
```


```python
arr
```




    array([[ 0,  1,  2,  3,  4],
           [ 5,  6,  7,  8,  9],
           [10, 11, 12, 13, 14]])




```python
arr.T
```




    array([[ 0,  5, 10],
           [ 1,  6, 11],
           [ 2,  7, 12],
           [ 3,  8, 13],
           [ 4,  9, 14]])



计算矩阵内积


```python
arr = np.random.randn(6, 3)
```


```python
arr
```




    array([[-0.45772682, -1.49471203,  0.64527333],
           [-0.77004567,  0.51840785,  1.51696764],
           [-0.18783066,  0.60890476,  1.49422724],
           [-0.24827084, -0.2243236 ,  0.97790424],
           [ 0.81824256,  1.34864471,  0.47445477],
           [ 1.43820443,  0.75117429, -1.08111617]])




```python
np.dot(arr.T, arr)
```




    array([[ 3.63735583,  2.41015478, -3.15358705],
           [ 2.41015478,  5.30710218,  0.34014944],
           [-3.15358705,  0.34014944,  7.30049974]])



对于⾼维数组，transpose需要得到⼀个由轴编号组成的元组才能对这些轴进⾏转置


```python
arr = np.arange(16).reshape((2, 2, 4))
```


```python
arr
```




    array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7]],
    
           [[ 8,  9, 10, 11],
            [12, 13, 14, 15]]])




```python
arr.transpose((1,0,2))
```




    array([[[ 0,  1,  2,  3],
            [ 8,  9, 10, 11]],
    
           [[ 4,  5,  6,  7],
            [12, 13, 14, 15]]])



第⼀个轴0被换成了第⼆个，第⼆个轴1被换成了第⼀个，最后⼀个轴2不变
（说实话，没懂）


```python
arr
```




    array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7]],
    
           [[ 8,  9, 10, 11],
            [12, 13, 14, 15]]])




```python
arr.swapaxes(1,2)
```




    array([[[ 0,  4],
            [ 1,  5],
            [ 2,  6],
            [ 3,  7]],
    
           [[ 8, 12],
            [ 9, 13],
            [10, 14],
            [11, 15]]])



###  4) 通⽤函数：快速的元素级数组函数

通⽤函数（即ufunc）是⼀种对ndarray中的数据执⾏元素级运算的函数。你可以将其看做简单函数（接受⼀个或多个标量值，并产⽣⼀个或多个标量值）的⽮量化包装器。

#### 一元ufunc


```python
arr = np.arange(10)
```


```python
arr
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
np.sqrt(arr)
```




    array([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,
           2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])




```python
np.exp(arr)
```




    array([1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01,
           5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03,
           2.98095799e+03, 8.10308393e+03])



#### 二元ufunc


```python
x = np.random.randn(8)
```


```python
y = np.random.randn(8)
```


```python
x
```




    array([-1.07601257,  0.38013997, -0.54146667,  0.13435886,  0.96489703,
           -1.59194477,  0.80121532,  0.36855646])




```python
y
```




    array([-0.44394313,  0.39340101, -1.55978622,  2.21252573, -0.27223131,
            0.89024545, -1.61407827,  1.51775185])




```python
np.maximum(x, y)
```




    array([-0.44394313,  0.39340101, -0.54146667,  2.21252573,  0.96489703,
            0.89024545,  0.80121532,  1.51775185])




```python
np.add(x, y)
```




    array([-1.51995569,  0.77354097, -2.10125289,  2.34688459,  0.69266572,
           -0.70169931, -0.81286295,  1.88630831])




```python
arr = np.random.randn(7) * 5
```


```python
arr
```




    array([ -2.07657247,   8.83202026, -12.60623561,  -0.53580635,
            -2.61961543,   5.35951667,  -4.02445755])



modf()表示解包浮点数，分解整数部分和小数部分


```python
remainder, whole_part = np.modf(arr)
```


```python
remainder
```




    array([-0.07657247,  0.83202026, -0.60623561, -0.53580635, -0.61961543,
            0.35951667, -0.02445755])




```python
whole_part
```




    array([ -2.,   8., -12.,  -0.,  -2.,   5.,  -4.])




```python
arr
```




    array([ -2.07657247,   8.83202026, -12.60623561,  -0.53580635,
            -2.61961543,   5.35951667,  -4.02445755])




```python
np.sqrt(arr)
```




    array([       nan, 1.31297818,        nan,        nan,        nan,
           1.2335044 ,        nan])




```python
np.sqrt(arr, arr)
```




    array([       nan, 1.72391169,        nan,        nan,        nan,
           1.52153311,        nan])




```python
arr
```




    array([       nan, 1.72391169,        nan,        nan,        nan,
           1.52153311,        nan])



![926_7.png](https://github.com/ta00231/data_analysis/blob/main/picture/926_7.png)

![926_8.png](https://github.com/ta00231/data_analysis/blob/main/picture/926_8.png)
