# 一、线性代数


```python
import numpy as np
```

## 1、dot 矩阵相乘


```python
x = np.array([[1.,2.,3.],[4.,5.,6.]])
```


```python
y = np.array([[6.,23.],[-1,7],[8,9]])
```


```python
x
```




    array([[1., 2., 3.],
           [4., 5., 6.]])




```python
y
```




    array([[ 6., 23.],
           [-1.,  7.],
           [ 8.,  9.]])




```python
x.dot(y)
```




    array([[ 28.,  64.],
           [ 67., 181.]])




```python
np.dot(x, np.ones(3))
```




    array([ 6., 15.])



@符（类似Python 3.5）也可以⽤作中缀运算符，进⾏矩阵乘法


```python
x @ np.ones(3)
```




    array([ 6., 15.])



## 2、numpy.linalg 用于矩阵分解运算的库


```python
from numpy.linalg import inv, qr
```


```python
X = np.random.randn(5, 5)
```


```python
mat = X.T.dot(X)
```


```python
inv(mat)
```




    array([[   1.07766359,    2.31648679,   -2.37119107,  -22.45589605,
              14.17379623],
           [   2.31648679,    9.52923299,   -7.83663328,  -79.66552831,
              50.64011128],
           [  -2.37119107,   -7.83663328,    7.35947508,   70.62769798,
             -44.82169788],
           [ -22.45589605,  -79.66552831,   70.62769798,  701.29275355,
            -445.22513963],
           [  14.17379623,   50.64011128,  -44.82169788, -445.22513963,
             282.94473513]])




```python
mat.dot(inv(mat))
```




    array([[ 1.00000000e+00, -8.20828678e-17,  3.01447564e-15,
            -9.05593068e-15, -2.65333270e-15],
           [-7.76098781e-16,  1.00000000e+00,  7.06300902e-15,
            -9.38456333e-14,  4.19645200e-14],
           [-3.23347994e-15, -8.17255684e-15,  1.00000000e+00,
             9.36651830e-14, -6.64458476e-14],
           [-1.13471315e-15, -7.09134983e-15,  8.49225156e-15,
             1.00000000e+00, -4.57471545e-14],
           [ 9.15972007e-15,  5.38183584e-14, -3.09115415e-14,
            -4.51724365e-13,  1.00000000e+00]])




```python
q, r = qr(mat)
```


```python
r
```




    array([[-4.83518998e+00, -2.88683658e+00, -1.90785268e-01,
            -1.53863045e+00, -1.69302679e+00],
           [ 0.00000000e+00, -3.73252685e+00,  5.30955406e+00,
            -2.72266705e-01,  1.08134261e+00],
           [ 0.00000000e+00,  0.00000000e+00, -3.23911117e+00,
             1.19904905e+00,  1.37445863e+00],
           [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
            -2.40446613e+00, -3.78626964e+00],
           [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
             0.00000000e+00,  1.87958818e-03]])



![926_11.png](attachment:926_11.png)

# 二、伪随机数生成

## random模块


```python
samples = np.random.normal(size=(4, 4))
```


```python
samples
```




    array([[ 0.29920729,  0.00341531, -1.12824627, -2.34434959],
           [-1.55316462,  1.46562839,  1.80346851,  0.25044899],
           [-0.44318314,  1.0894698 ,  0.07961771, -0.50677621],
           [-1.09927183,  0.8679417 , -0.42039586,  0.84122433]])



normal生成标准正态分布的size大小样本数组


```python
np.random.seed(1234)
```

numpy.random的数据⽣成函数使⽤了全局的随机种⼦。要避免全局状态，你可以使⽤numpy.random.RandomState，创建⼀个
与其它隔离的随机数⽣成器


```python
rng = np.random.RandomState(1234)
```


```python
rng.randn(10)
```




    array([ 1.15003572,  0.99194602,  0.95332413, -2.02125482, -0.33407737,
            0.00211836,  0.40545341,  0.28909194,  1.32115819, -1.54690555])



![926_12.png](attachment:926_12.png)

### 示例：随机漫步


```python
nsteps = 1000
```


```python
draws = np.random.randint(0, 2, size=nsteps)
```


```python
steps = np.where(draws > 0, 1, -1)
```


```python
walk = steps.cumsum()
```


```python
walk.min()
```




    0




```python
walk.max()
```




    55




```python
(np.abs(walk) >= 10).argmax()
```




    13



np.abs(walk)>=10可以得到⼀个布尔型数组，它表示的是
距离是否达到或超过10，⽽我们想要知道的是第⼀个10或－10
的索引。可以⽤argmax来解决这个问题，它返回的是该布尔型
数组第⼀个最⼤值的索引（True就是最⼤值）

#### ⼀次模拟多个随机漫步


```python
nwalks = 5000
```


```python
nsteps = 1000
```


```python
draws = np.random.randint(0, 2, size=(nwalks,nsteps))
```


```python
steps = np.where(draws > 0, 1, -1)
```


```python
walks = steps.cumsum(1)
```


```python
walks
```




    array([[  1,   2,   3, ..., -26, -27, -28],
           [ -1,  -2,  -3, ..., -12, -13, -12],
           [  1,   0,   1, ...,  46,  45,  44],
           ...,
           [ -1,  -2,  -3, ...,  32,  33,  34],
           [ -1,   0,   1, ...,  -6,  -5,  -4],
           [ -1,  -2,  -1, ..., -18, -19, -18]], dtype=int32)




```python
walks.max()
```




    122




```python
walks.min()
```




    -128




```python
hist30 = (np.abs(walks) >= 30).any(1)
```


```python
hist30
```




    array([ True,  True,  True, ...,  True, False,  True])




```python
hist30.sum()
```




    3367




```python
walks[hist30]
```




    array([[  1,   2,   3, ..., -26, -27, -28],
           [ -1,  -2,  -3, ..., -12, -13, -12],
           [  1,   0,   1, ...,  46,  45,  44],
           ...,
           [  1,   0,   1, ...,  64,  65,  66],
           [ -1,  -2,  -3, ...,  32,  33,  34],
           [ -1,  -2,  -1, ..., -18, -19, -18]], dtype=int32)




```python
crossing_times = (np.abs(walks[hist30]) >= 30).argmax()
```


```python
crossing_times.mean()
```




    343.0


